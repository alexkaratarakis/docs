<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="features-feature-packages">Features / Feature packages</h1>
<h2 id="motivation">1. Motivation</h2>
<h3 id="a.-opencv-cuda">A. OpenCV + CUDA</h3>
<p><a href="http://opencv.org/">OpenCV</a> is a computer vision library that can optionally be built with CUDA support to massively accelerate certain tasks when using computers with NVidia GPUs. For users without NVidia GPUs, building with CUDA support provides no benefit. <a href="http://www.nvidia.com/object/cuda_home_new.html">CUDA</a> is provided only via a 1.3 GB installer (at the time of this authoring), which requires administrator access to install and modifies the global system state.</p>
<p>Therefore, there is significant value in enabling users to choose whether they find CUDA support valuable for their particular scenario.</p>
<h3 id="b.-opencv-opencv_contrib">B. OpenCV + OpenCV_contrib</h3>
<p>The community around <a href="http://opencv.org/">OpenCV</a> has built up a library of extensions called <a href="https://github.com/opencv/opencv_contrib">OpenCV_contrib</a>. However, these extensions are a source-level patch onto the main OpenCV codebase and therefore must be applied <em>during</em> the core OpenCV build. Further confounding the problem, it is the author’s understanding that these community extensions have only been developed with <a href="http://www.nvidia.com/object/cuda_home_new.html">CUDA</a> enabled and cannot be built without that dependency.</p>
<p>Therefore, if CUDA is disabled, OpenCV_contrib must also be disabled. Likewise, when a user requests OpenCV_contrib, CUDA must be enabled. It would be convienent, but not a requirement, to enable CUDA without enabling the community extensions.</p>
<p>Finally, these extensions add additional exports and headers which could be depended upon by other libraries. For maintainers, there must be a way to specify this requirement such that <code>vcpkg install mylib-depends-ocv-contrib</code> will verify/build/rebuild OpenCV with the community extensions enabled.</p>
<h3 id="c.-c-rest-sdk-signalr">C. C++ REST SDK + SignalR</h3>
<p>The <a href="https://github.com/Microsoft/cpprestsdk">C++ REST SDK</a> is a networking library that provides (among other features) HTTP and Websockets clients. To implement the HTTP client functionality on Windows Desktop, only the core Win32 platform APIs are needed (<code>zlib</code> is optional). However, the websockets client is based on <a href="https://www.zaphoyd.com/websocketpp/">Websockets++</a>, which adds mandatory dependencies on <code>boost</code>, <code>openssl</code>, and <code>zlib</code>. Many users of the C++ REST SDK do not use the websockets component, so to minimize their overall dependency footprint it can be disabled at build time. Ideally, this option would be easily accessible to users who are concerned about the final size or licensing of their deployment.</p>
<p>However, <a href="https://github.com/aspnet/SignalR-Client-Cpp">SignalR-Client-Cpp</a> depends on the websockets functionality provided by the C++ REST SDK. Therefore, the maintainers of the <code>signalrclient</code> port would ideally like to express this dependency such that <code>cpprestsdk</code> will be correctly built for their needs. Note that <code>signalrclient</code> does not <em>inherently</em> care about <code>boost</code>, <code>websocketspp</code> or <code>openssl</code>, rather it depends only on the public websocket client APIs provided by <code>cpprestsdk</code>. It would be much more maintainable to declare dependencies based on the public APIs rather than the dependencies themselves.</p>
<h2 id="other-design-concerns">2. Other design concerns</h2>
<ul>
<li><p>General-purpose Open Source projects must be able to easily and succinctly describe their build dependencies inside Vcpkg. This should be no more verbose than a single <code>vcpkg install</code> line and, when that command succeeds, there is a guarantee that all required functionality/headers/imports are available.</p></li>
<li><p>The internal state of the Vcpkg enlistment must be either extremely transparent OR managed by version control (git). This enables larger projects to efficiently transfer the entire state of their customized Vcpkg system between machines (and onto build servers) by having the destination clone and then run a single <code>vcpkg install</code> line for the subset of dependencies required. The results of this operation should be as repeatable as reasonably achievable given the current limits of the underlying toolchain.</p></li>
</ul>
<h2 id="proposed-solution">3. Proposed solution</h2>
<p>A key summary of the above motivations is that they are all scenarios surrounding APIs that are not independently buildable from each other. We have an existing solution for APIs that are independently buildable: separate packages. Therefore, we seek to extend the user-facing notion of “packages” to include capabilities and contracts that may not be build-time independent.</p>
<p>This document proposes “features” (also called feature packages). These features are intended to model semi-independently toggleable API sets/contracts such that they can be sanely depended upon by other packages. It is not a goal to model exclusive alternatives (such as implementation choices that are not user-observable) through this mechanism.</p>
<ul>
<li>Individual libraries within <code>boost</code> may be reasonably represented as features.</li>
<li>Whether a graphics library is built on DirectX xor OpenGL (where one but not both must be chosen) is not representable as a feature.</li>
</ul>
<p>From a user experience perspective (i.e. from <code>vcpkg install</code>) feature packages act as much as possible like completely independent packages. However, internally, any change to a package’s features will result in a rebuild of the associated “parent” package. This will invoke a package rebuild experience similar to upgrading.</p>
<p>When using <code>vcpkg install &lt;package&gt;</code>, some features will be enabled by default. These default features can be avoided by referring to the packages as <code>&lt;package&gt;/core</code> and features can be added by supplying them on the same installation line.</p>
<h3 id="a.-proposed-user-experience">A. Proposed User experience</h3>
<h4 id="i.-user-with-no-preference-about-options">i. User with no preference about options</h4>
<p>Install of a library with default features:</p>
<pre><code>&gt; vcpkg install cpprestsdk
// -- omitted build information -- //
Package cpprestsdk/core:x86-windows is installed.
Package cpprestsdk/compression:x86-windows is installed.
Package cpprestsdk/ws-client:x86-windows is installed.</code></pre>
<p>Removal of that library:</p>
<pre><code>&gt; vcpkg remove cpprestsdk
The following packages will be removed:
    cpprestsdk:x86-windows
Removing package cpprestsdk:x86-windows...
Removing package cpprestsdk:x86-windows... done
Purging package cpprestsdk:x86-windows...
Cleaned up D:\src\vcpkg\packages\cpprestsdk_x64-windows
Purging package cpprestsdk:x86-windows... done</code></pre>
<p>Installation of a library with optional features:</p>
<pre><code>&gt; vcpkg install opencv
// -- omitted build information -- //
Package opencv/core:x86-windows is installed.</code></pre>
<h4 id="ii.-user-desires-cuda-support-for-opencv-directly-and-is-unfamiliar-with-feature-packages">ii. User desires CUDA support for OpenCV directly, and is unfamiliar with feature packages</h4>
<p>Developer Bob knows he wants OpenCV, so he guesses what the package is called</p>
<pre><code>&gt; vcpkg install opencv
// -- omitted build information -- //
Package opencv/core:x86-windows is installed.</code></pre>
<p>Bob attempts to build his application against OpenCV (assuming CUDA), which fails at runtime or compile time indicating that OpenCV wasn’t built with CUDA. Bob comes back to vcpkg, not knowing about the “feature packages” feature. The primary inquiry tools for Vcpkg are <code>search</code> and <code>list</code>, so he runs <code>vcpkg search</code>:</p>
<pre><code>&gt; vcpkg search opencv
opencv               3.2.0            computer vision library
opencv/cuda                           support for NVidia CUDA
opencv/contrib                        community supported extensions for OpenCV

If your library is not listed, please open an issue at:
    https://github.com/Microsoft/vcpkg/issues</code></pre>
<p>He isn’t immediately sure what the lack of a version number means, but anything in <code>vcpkg search</code> can be applied to <code>vcpkg install</code>, so he runs:</p>
<pre><code>&gt; vcpkg install opencv/cuda
The following packages will be rebuilt:
    opencv:x86-windows

To rebuild with this feature, use:
    vcpkg remove opencv:x86-windows
    vcpkg install opencv/core,cuda:x86-windows</code></pre>
<p>Bob follows the instructions…</p>
<pre><code>&gt; vcpkg remove opencv:x86-windows
// -- omitted results as above -- //
&gt; vcpkg install opencv/core,cuda:x86-windows
// -- omitted build information -- //
Package opencv/core:x86-windows is installed.
Package opencv/cuda:x86-windows is installed.</code></pre>
<p>and he can now use OpenCV’s CUDA support in his application.</p>
<h4 id="iii.-user-is-familiar-with-feature-packages-and-wants-to-opt-out-of-a-feature">iii. User is familiar with feature packages, and wants to opt-out of a feature</h4>
<p>Developer Alice has used <code>cpprestsdk</code>, built it from source, and she knows about the option to disable websockets. She uses <code>search</code> to find the complete list of features:</p>
<pre><code>&gt; vcpkg search cpprestsdk
cpprestsdk           2.9.0-2          C++11 JSON, REST, and OAuth library The C++ RES...
cpprestsdk/compression                Gzip compression support in the HTTP client.
cpprestsdk/ws-client                  Websocket client support based on websocketspp.

If your library is not listed, please open an issue at:
    https://github.com/Microsoft/vcpkg/issues</code></pre>
<p>She decided she only wants <code>cpprestsdk/compression</code>, so she installs only that feature:</p>
<pre><code>&gt; vcpkg install cpprestsdk/compression
// -- omitted build information -- //
Package cpprestsdk/core:x86-windows is installed.
Package cpprestsdk/compression:x86-windows is installed.</code></pre>
<p>She receives a quick recursive build that only depends on <code>zlib</code>.</p>
<p>She’s now interested in some additional libraries built on top of cpprestsdk: <code>azure-storage-cpp</code> and <code>signalrclient</code>.</p>
<pre><code>&gt; vcpkg install azure-storage-cpp
// -- omitted build information -- //
Package azure-storage-cpp/core:x86-windows is installed.

&gt; vcpkg install signalrclient
Package signalrclient:x86-windows depends on cpprestsdk/ws-client:x86-windows.

The following packages will be rebuilt:
  * azure-storage-cpp:x86-windows
  * cpprestsdk:x86-windows

To rebuild the current package graph with this feature, use:
    vcpkg remove cpprestsdk:x86-windows azure-storage-cpp:x86-windows
    vcpkg install cpprestsdk/core,compression,ws-client:x86-windows
    vcpkg install azure-storage-cpp/core:x86-windows
    vcpkg install signalrclient/core:x86-windows</code></pre>
<p>She follows the above script and can use both <code>azure-storage-cpp</code> and <code>signalrclient</code> in her code.</p>
<p>Some time has passed, she decided not to use <code>signalrclient</code>, and she’s interested in shipping her application. She wants to minimize her final install size, so she’d like to remove all unneeded packages like <code>boost</code> and <code>openssl</code>.</p>
<pre><code>&gt; vcpkg remove boost openssl
The following packages and features will be removed:
  * signalrclient/core:x86-windows
  * cpprestsdk/ws-client:x86-windows
    boost/core:x86-windows
    openssl/core:x86-windows

The following packages will be rebuilt:
  * azure-storage-cpp:x86-windows
  * cpprestsdk:x86-windows

Removing features requires rebuilding packages.
To rebuild the current package graph without these features, use:
    vcpkg remove cpprestsdk:x86-windows azure-storage-cpp:x86-windows signalrclient:x86-windows openssl:x86-windows boost:x86-windows
    vcpkg install cpprestsdk/core,compression:x86-windows
    vcpkg install azure-storage-cpp/core:x86-windows</code></pre>
<p>In the end, her final <code>vcpkg list</code> outputs:</p>
<pre><code>&gt; vcpkg list
zlib/core:x86-windows              1.2.11          A compression library
azure-storage-cpp/core:x86-windows 2.6.0           Microsoft Azure Storage Client SDK for ...
cpprestsdk/core:x86-windows        2.9.0-2         C++11 JSON, REST, and OAuth library
cpprestsdk/compression:x86-windows                 Gzip compression support in the HTTP client.</code></pre>
<h3 id="b.-technical-model">B. Technical model</h3>
<ul>
<li>Each package can have any number “features”.</li>
<li>Features follow the same naming conventions as packages, but when referenced are always “namespaced” by the parent package.
<ul>
<li><code>cpprestsdk/ws-client</code> is a completely orthogonal feature from <code>poco/ws-client</code>.</li>
</ul></li>
<li>Features are valid dependencies.
<ul>
<li><code>signalrclient</code> depends on <code>cpprestsdk/ws-client</code></li>
</ul></li>
<li>Features can have dependencies (including other features).
<ul>
<li><code>cpprestsdk/ws-client</code> depends on <code>boost</code>, <code>openssl</code>, and <code>websocketspp</code></li>
<li><code>opencv/cuda</code> depends on <code>cuda</code></li>
<li><code>opencv/contrib</code> depends on <code>opencv/cuda</code></li>
<li><code>boost/python</code> depends on <code>libpython</code></li>
</ul></li>
<li>Every package has an implicit feature called <code>core</code>, which covers the core library without any features enabled. All features implicitly depend on the <code>core</code> feature of their parent package
<ul>
<li><code>azure-storage-cpp</code> depends on <code>cpprestsdk/core</code></li>
</ul></li>
<li>Each package declares a list of default features that are enabled when the package is referred to by its raw name, and <code>core</code> is implicitly a default feature.
<ul>
<li><code>cpprestsdk</code> declares <code>ws-client</code> to be a default feature. Any reference <code>cpprestsdk</code> implicitly means <code>cpprestsdk/core</code> <em>and</em> <code>cpprestsdk/ws-client</code>.</li>
<li><code>opencv</code> does not declare <code>cuda</code> nor <code>contrib</code> to be default features.</li>
</ul></li>
</ul>
<p>As a conclusion of the above, it is expected that all packages will be buildable with all features disabled (just the <code>core</code> feature) OR with all features enabled.</p>
<h2 id="related-work">4. Related Work</h2>
<h3 id="cargos-features-from-rust-httpdoc.crates.iomanifest.htmlthe-features-section">Cargo’s Features (from Rust): <a href="http://doc.crates.io/manifest.html#the-features-section" class="uri">http://doc.crates.io/manifest.html#the-features-section</a></h3>
<p>The proposed feature packages are exceedingly similar to Cargo’s Features, with the following changes:</p>
<ul>
<li>We avoid any collision problems because features are always namespaced by the owning package</li>
<li>We do not have a concept of “feature groups”, instead we allow dependencies from one feature to another within the same package (Note: This may be how “feature groups” are implemented internally to Cargo – it was not clear from the documentation).</li>
<li>Because of the nature of C and C++, it is extremely commonplace that large software packages can have features disabled to remove their dependencies upon other libraries. Changing this configuration requires a rebuild of the package and potentially rippling ABI changes to any downstream dependencies. Therefore, we expect significantly more use of this feature to manage optional API contracts instead of the intended use in Cargo (curation).</li>
<li>We do not intend feature packages to be used to express the curation relationship.</li>
</ul>
<h3 id="gentoos-use-flags-httpswiki.gentoo.orgwikihandbookx86workinguse">Gentoo’s USE flags: <a href="https://wiki.gentoo.org/wiki/Handbook:X86/Working/USE" class="uri">https://wiki.gentoo.org/wiki/Handbook:X86/Working/USE</a></h3>
<p>Gentoo’s USE flags can be shortly summarized as a global set of keywords that is used to make cross-cutting changes to the entire package graph’s build configuration. This system standardizes many common settings such that they can be simultaneously toggled for the entire graph. The most common example of this would be using KDE vs Gnome. A user who knows that, given the choice, they would prefer the KDE/Qt interface can manage the massive space of package configuration efficiently without learning the particular term that each package has decided to call “build using Qt instead of GTK”.</p>
<p>USE flags can be customized hierarchically when needed, including at the per-package level. They can be depended upon by other packages, both positively and negatively. USE flags themselves can be used in any boolean expression to determine the complete set of package dependencies, including removing dependencies when flags are enabled.</p>
<p>Problems with USE flags:</p>
<ul>
<li>They require significant coordination from package maintainers. This increases the burden of adding a package – to author a good package, I need to be aware of every uncommon USE flag and evaluate how those could map onto my local configuration space.</li>
<li>Based on research online, it seems extremely common that users need to tweak flags at a per-package level. This calls into question how valuable the cross-cutting power above is.</li>
<li>The vast majority of common USE flags are essentially a list of all the common packages and focus on giving the user a view of dependencies (which a package manager is designed to hide when possible) instead of features (which is what users normally care about).</li>
<li>Dependency analysis with USE flags becomes a SAT problem with an enormous state space – P*F bits – which compounds with any versioning relations. This works acceptably in practice via heuristics, but it implies that a) there is a looming performance wall which could suddenly create a poor user experience and b) the heuristics may not correctly model the user’s needs, which can cause a disconnect in desire vs practice, which again causes a poor user experience.</li>
</ul>
</body>
</html>
